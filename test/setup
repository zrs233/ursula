#!/bin/bash
set -eu
source $(dirname $0)/common

$root/test/check-deps

source $HOME/.stackrc

destroy_vms

echo "setting up ssh key"
if ! nova keypair-list | grep $key_name >/dev/null; then
  nova keypair-add $key_name > $key_path
  chmod 600 $key_path
fi

echo "setting up security group"
if ! nova secgroup-list | grep $security_group >/dev/null; then
  nova secgroup-create $security_group "Rules for testing ursula" >/dev/null
fi

echo "setting up security group rules"
default_proto=tcp
default_ports=(22 80 443 3306 4444 4567 4568 5000 5001 5672 8777 8778 9393 9797 11211 35357 35358)
default_cidr=0.0.0.0/0
rules=$(nova secgroup-list-rules $security_group)
security_group_id=$(nova secgroup-list | grep $security_group | awk -F\| '{print $2}' | tr -d ' ')

for port in "${default_ports[@]}"; do
  regexp="$default_proto .* \| $port .* \| $port .* \| $default_cidr"
  if ! echo "$rules" | egrep "$regexp" >/dev/null; then
    echo "- creating new security group rule for port $port"
    nova secgroup-add-rule $security_group $default_proto $port $port $default_cidr >/dev/null
  fi
done

echo "booting vms"
net_id=$(nova net-list | grep " internal " | awk '{print $2}')
for vm in $vms; do
  nova boot --image $image --flavor $flavor --key_name $key_name --nic net-id=$net_id --security-groups $security_group_id $vm >/dev/null
  sleep 15
  add_floating_ip $vm
done

echo "waiting for vms to come up"
for vm in $vms; do
  while ! nova list | grep $vm | grep ACTIVE >/dev/null; do sleep 1; echo -n '.'; done; echo
  ip=$(public_ip $vm)
  echo "$vm $ip: waiting for sshd"
  until echo '' | nc $ip 22 2>&1 >/dev/null; do echo -n '.'; sleep 1; done

  # hostkeys are currently not generated until a few seconds after sshd comes up.
  until ssh $ssh_args $login_user@$ip uptime 2>&1 >/dev/null; do
    echo -n '.'
    sleep 1
  done

  ssh $ssh_args $login_user@$ip "echo '127.0.1.1 $vm' | sudo tee -a /etc/hosts"

  # TODO: this is a workaround for an MTU issue. it should be removed once fixed.
  ssh $ssh_args $login_user@$ip sudo ifconfig eth0 mtu 1454 2>&1 >/dev/null

  ssh $ssh_args $login_user@$ip sudo mkdir -p /root/.ssh 2>&1 >/dev/null
  ssh $ssh_args $login_user@$ip sudo cp /home/$login_user/.ssh/authorized_keys /root/.ssh/. 2>&1 >/dev/null
done
controller_ip=$(public_ip test-controller-0)

echo "building config"
rm -rf $root/envs/test
cp -r $root/envs/example $root/envs/test
sed -i -e "s/^controller_primary: \&controller.*/controller_primary: \&controller $controller_ip/" envs/test/group_vars/all.yml

echo "generating ssl cert for $controller_ip"
cert_dir=$(mktemp -d 2> /dev/null || mktemp -d -t 'setup')
pushd $cert_dir
$root/test/gen-cert $controller_ip
cat >> $root/envs/test/group_vars/all.yml <<eof
nginx:
  crt: |
eof
cat $cert_dir/$controller_ip.crt | sed 's/^/    /' >> $root/envs/test/group_vars/all.yml
cat >> $root/envs/test/group_vars/all.yml <<eof
  key: |
eof
cat $cert_dir/$controller_ip.key | sed 's/^/    /' >> $root/envs/test/group_vars/all.yml
popd
rm -rf $cert_dir


echo "writing inventory file"
cat > $root/envs/test/hosts <<eof
[db]
$(public_ip "test-controller-0")
$(public_ip "test-controller-1")

[db_arbiter]
$(public_ip "test-compute-0")

[controller]
$(public_ip "test-controller-0")
$(public_ip "test-controller-1")

[compute]
$(public_ip "test-compute-0")

[network]
$(public_ip "test-controller-0")
eof

echo "vms are up: $vms !!"
